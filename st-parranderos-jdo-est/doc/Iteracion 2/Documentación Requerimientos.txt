DOCUMENTACIÓN DE NUEVOS REQUERIMIENTOS FUNCIONALES Y DE CONSULTA DE LA ITERACIÓN 2

//REQUERIMIENTOS FUNCIONALES//

RF12 - SOLICITAR UN CARRITO DE COMPRAS

Para este requerimiento fue necesario crear una nueva tabla A_CARRITO. El carrito de compras tiene un id (llave primaria) y una contraseña. El proceso de asignación empieza con la verificación de que el carrito asignado no esté en uso (estado = "en uso"). Después, el usuario/cliente debe ingresar una contraseña definida por él mismo, y de esta manera se le asignará un carrito. (Cabe aclarar que por términos de diseño y facilidad planteamos que existían un máximo de 20 carritos y que todos iniciarán con clave 0 que significa que están libres, al asignar un carrito, se van tomando en orden por id los carrito y se le ase¡signan al cliente con la contraseña que el definió, si suelta el carrito o realiza el pago, la contraseña vuelve a ser 0 y el carrito queda libre para usar). Una vez el cliente escriba la contraseña, el estado del carrito pasará a estar en uso y solo podrá ser utilizado por el cliente.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de asignar un carrito tenemos varias partes en la transacción por lo que inicialmente se verifica que el carro no esté en uso y ahí sí se procede a asignar un carrito libre. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. El carrito al estar en uso no podrá ser utilizado por otro usuario hasta que su estado sea abandonado o libre, esto lo verificamos y validamos en la lógica (Aislamiento). Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad).

RF13 - ADICIONAR UN PRODUCTO AL CARRITO DE COMPRAS

En este requerimiento, se solicita al cliente que ingrese la contraseña de su carrito para identificar qué carrito le pertenece y así mismo se valida que la clave sea correcta. Después de encontrar el carrito se procede a vincular un producto existente en SuperAndes con el carrito. Esto se hace a través de una nueva tabla en la base de datos A_CONTIENE que modela la clase de asociación entre un producto y un carrito. En esta tabla se tiene el id del carrito, el id del producto y la cantidad de unidades por producto que se va a agregar. De esta manera, el carrito quedará asociado a uno o más productos que defina el cliente (uno a muchos). Una vez agregado el producto, se procede a actualizar el inventario parcial de SuperAndes. Esto se hace disminuyendo las existencias del estante de la sucursal de donde fue agregado el producto al carrito. Así, el inventario restará la cantidad de unidades que el cliente solicitó agregar al carrito y así, los datos se mantendrán consistentes.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de adicionar un producto a un carrito tenemos varias partes en la transacción por lo que inicialmente se verifica que la contraseña del carrito sea valida y exista. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. El carrito al estar en uso no podrá ser utilizado por otro usuario hasta que su estado sea abandonado o libre, esto lo verificamos y validamos en la lógica (Aislamiento). Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad). Por otro lado, el producto debe existir o sino no podrá agregarse, esto se verifica con las CONSTRAINTS de llaves foráneas que se tienen en las tablas de ALMACENAMIENTO, SUCURSAL y VENDE.

RF14 - DEVOLVER UN PRODUCTO DEL CARRITO DE COMPRAS

En este requerimiento, se solicita al cliente que ingrese la contraseña de su carrito para identificar qué carrito le pertenece y así mismo se valida que la clave sea correcta. Después de encontrar el carrito se procede a devolver un producto existente en el carrito al estante de donde fue tomado. Para saber qué producto se va a devolver, en la Tabla A_CONTIENE, traducida en una clase SQLContiene.java, se tiene un método que retorna la tupla de (idCarrito,idProducto). De esta manera se sabrá que producto se eliminará del carrito y así mismo se puede consultar la cantidad de unidades del producto. Una vez se sabe esto, se elimina esa tupla de la base de datos y del carrito respectivamente. Finalmente, se actualiza el inventario de SuperAndes, aumentando nuevamente las existencias del estante de la sucursal de donde fue tomado el producto(s). Así los datos serán consistentes y acordes a las reglas de negocio.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de devolver un producto del carrito al estante, tenemos varias partes en la transacción por lo que inicialmente se verifica que la contraseña del carrito sea valida y exista. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. El carrito al estar en uso no podrá ser utilizado por otro usuario hasta que su estado sea abandonado o libre, esto lo verificamos y validamos en la lógica (Aislamiento). Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad). Por otro lado, el producto especificado DEBE estar en el carrito y la cantidad de unidades del producto dbee ser mayor a 0 y máximo la cantidad de unidades adicionadas inicialmente, esto se valida en la lógica para que los datos sean consistentes.

RF15 - PAGAR LA COMPRA

En este requerimiento, se solicita al cliente que ingrese la contraseña de su carrito para identificar qué carrito le pertenece y así mismo se valida que la clave sea correcta, de esta manera se sabrá qué carrito va a pagarse y facturar los productos. Después de encontrar el carrito se procede a generar una factura y a crear una transacción por cada producto dentro del carrito, de esta manera se tendrá un costo total para la factura. Este proceso hace un recorrido de todas las tuplas de la tabla A_CONTIENE y a cada una, le genera una transacción asociada a la factura que se acaba de crear. Después de eso, el método verifica que las existencias que se actualizaron al pagar la compra no estén por debajo del nivel de reorden del almacenamiento, si lo sobrepasan, se deberá solicitar un nuevo pedido para reabastecer el inventario de SuperAndes.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de pagar una compra, tenemos varias partes en la transacción por lo que inicialmente se verifica que la contraseña del carrito sea valida y exista. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad).

RF16 - ABANDONAR UN CARRITO DE COMPRAS

En este requerimiento, se solicita al cliente que ingrese la contraseña de su carrito para identificar qué carrito le pertenece y así mismo se valida que la clave sea correcta, de esta manera se sabrá qué carrito se va a abandonar. Después de encontrar el carrito se procede a cambiar el estado del carrito de "en uso" a "abandonado". Así mismo, la clave del carrito se cambiará a 0 nuevamente y estará disponible para ser asociado a otro cliente. Los productos que estaban en el carrito seguirán estando ahí debido a que el cliente no pagó la compra, los productos serán devueltos a sus estantes correspondientes cuando se realice el proceso de recolectar productos abandonados.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de abandonar un carrito tenemos varias partes en la transacción por lo que inicialmente se verifica que la contraseña del carrito sea valida y exista. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. El carrito al estar en uso no podrá ser utilizado por otro usuario hasta que su estado sea abandonado o libre, en este caso la clave será 0 nuevamente y esto lo verificamos y validamos en la lógica (Aislamiento). Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad).

RF17 - RECOLECTAR PRODUCTOS ABANDONADOS

En este requerimiento, se tuvieron que crear varios métodos de consulta a la base de datos para facilitar el manejo de la información obtenida para así recolectar los productos del carrito abandonado. Inicialmente se ingresan en una lisa de arreglos de tipo Object, todos los carritos que estén en estado "abandonado", incluyendo en cada tupla, el estado, el producto que tiene, la cantidad de unidades y el id. Una vez se tiene la lista, se recorre y se divide cada elemento de la lista en tipo de dato long que definen cada casilla de la tupla. De esta manera se puede proceder a eliminar el producto del carrito teniendo su información específica. El recorrido de la lista finaliza cuando se hayan eliminado todos los productos de todos los carrito abandonados. A continuación, se obtienen por medio de otro método, las duplas que contienen la cantidad de unidades y existencias en almacenamiento de todos los productos que estén en los carritos de estado abandonado. De esta manera se podían manejar las tuplas para ejecutar el proceso de actualizar inventario de estantes y que todos los productos regresen a sus estantes correspondientes.

En la lógica del programa se utilizan las líneas de código tx.begin() y tx.commit() las cuales definen el inicio y final de una transacción. En el proceso de adicionar un producto a un carrito tenemos varias partes en la transacción por lo que inicialmente se verifica que la contraseña del carrito sea valida y exista. En oracle lo tenemos configurado como READ COMMITED y el AUTOCOMMIT desactivado de esta manera aseguramos que los datos sean íntegros y consistentes con la base de datos y las reglas de negocio. El carrito al estar en uso no podrá ser utilizado por otro usuario hasta que su estado sea abandonado o libre, esto lo verificamos y validamos en la lógica (Aislamiento). Así mismo, en la lógica tenemos las cláusulas de try/catch que ejecutan el rollback si en algún punto de la transacción esta no se completó debidamente (Atomicidad). Por otro lado, el producto debe existir o sino no podrá agregarse, esto se verifica con las CONSTRAINTS de llaves foráneas que se tienen en las tablas de ALMACENAMIENTO, SUCURSAL y VENDE.

//REQUERIMIENTOS DE CONSULTA//

RFC7 - ANALIZAR LA OPERACIÓN DE SUPERANDES

Para este requerimiento, el usuario debe ingresar una unidad de tiempo y un tipo de producto. De acuerdo con estos datos, se busca en la tabla de transacciones aquellas que incluyan un producto con el tipo especificado, para ello, se revisa también en la tabla de productos y se verifica el tipo de acuerdo con su identificador. En la tabla de transacciones existe un costo (que se calcula multiplicando el precio del producto en esa sucursal por el numero de unidades que se van a llevar; y estas transacciones están asociadas a una factura, que tiene como atributo la fecha de creación de la misma. A partir de ello, podemos extraer la fecha de esa transacción haciendo uso de esa foreign key, y a partir de la fecha, y dependiendo de la unidad de tiempo que el cliente haya dado, la idea es ir separando a las transacciones en grupos de fechas. Luego se suman los costos de las transacciones por cada grupo (o las unidades que se vendieron) y a partir de ello se puede saber el grupo que más vendió (en dinero o unidades).

RFC8 - ENCONTRAR LOS CLIENTES FRECUENTES

Para este requerimiento se implementó una sentencia sql la cual obtenía la información  básica de la factura (fecha en día, mes y año; cliente; id) dada una sucursal, y de esa selección se realiza un COUNT para generar un nuevo conjunto de datos con las facturas por un cliente, teniendo la condición de que sean mayor a 2. Estos datos se organizan por mes y año y retornan los clientes más frecuentes de SuperAndes.

Los aspectos básicos de ACID fueron manejados con verificaciones en Java y así mismo en SQLDeveloper se configuró el autocommit como desactivado y el estado de aislamiento en READ COMMITTED.


DISEÑO Y DESARROLLO DE LA LÓGICA REALIZADO POR: Nicolás Cobos, Juan Felipe Torres Piza. Grupo A-10

